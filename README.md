# SDCL Methodologies

Author- Matthew Sides

## Table of Contents-

[1] SDLC 

[2] SDLC Methodologies

[3] FSM and EFSM

[4] Behavioural  Specification Methods

[5] How the use of the function design paradigm in the software development lifecycle can improve software quality

### [1] SDLC 

SDLC or the abbreviated term System Development Life Cycle is a term generallly applied to system engineering, information systems and software engineering to describe the  process for planning, creating, testing, and deploying an information system.

### [2] SDLC Methodologies

There are numerous SDLC Methodologies or ways in which to portray the proccess of the plan, creation and deployment of an information system. The methods usually consist of various benefits though also wrought disadvantages if used incorrectly or in the wrong situation since each model is designed and deseganated for a different situation as it is likely that the creator created the system in order to fix their own issues which could not be fixed by following the current models of their time (essentially building upon models to improve the efficency or creating a new model to cater to their situation). 

A few of the models are realiterated below in detail, going through the models purpose or brief definition, the advantages, disadvantages of each model and one or two examples as to where the methodology or model would be applied;

### Waterfall method-

The waterfall is a sequentian non-iterative design model , used in software development proccesses. Furthermore as suggested in the conceptual name and illustrated in the  overall outlook of the theoretical waterfall model it can be likened to that of a literal waterfall, following a similiar system; flowing steadily downwards (hence the name waterfall) through phases of conception, initiation, analysis, design, construction, testing, production/implementation and maintenance.

#### Disadvatages 

The disadvantages of the waterfall model essentailly stem from the inability to track back once the testing stage had been reached which is detremental particuarlly in a long term massive project with numerous epics,as for instance if a group of developers are asked to create a system for a govering body (goverment or group) but the leaders of the governing body change with those who may have different ideologys in comparision to the previous leaders it is likely that the developers will be asked to alter a huge portion of the program and since with the water fall model it is essentially impossible to track back it is likely that the group of developers will have to start again making all there previous work futile (useless/worthless).

Therefore the waterfall methodology can only really work or be applied in instances where the project that is being handled is small and there are no uncertain requirements.

Another disadvantage is that no working software is produced until late during the life cycle, meaning that the developers will have to use conceptual designs and hope that once the theory is put into practice the software works, whilst the conceptual ideas will have to be solid to back up their ideas when talking with investors or whoever the program is being designed and created for.

The following point links in with the disadvantage noted above and that is that there is a high risk and uncertainty, meaning that though something may seem or sound pluasable during design and planning stage it may not actually function correctly when initiated in the production phase.

#### Advantages

The advantages of the waterfall model consist of the simple methodology and structure behind the model, making it easy to understand and use as like a waterfall the proccessess only flow one way not branching back or off the rythm or flow. 

Furthermore in this model phases are processed and completed one at a time, therefore phases do not overlap.
Whilst it is also easy to manage due to the rigidity of the model, each phase has specific deliverables and a review process.

#### Example 

For the type of software products that do not change very much once they are specified (for instance; a personilized data base) , the waterfall model is still viable. However, for software products that have their feature sets redefined during development because of user feedback and other factors, the traditional waterfall model is no longer appropriate.

### Evolutionary Model

The Evolutionary Model or approach is based on the idea of rapidly developing an initial software implementation from very abstract specifications and modifying this according to an appraisal (phases are concurrent and feedback is given and used between each phase). 

#### Advantages 

This is the only method appropriate for situations where a detailed system specification is unavailable. Effective in rapidly producing small systems, software with short life spans, and developing sub-components of larger systems.

#### Disadvantages

It is difficult to measure progress and produce documentation reflecting every version of the system as it evolves. This paradigm usually results in badly structured programs due to continual code modification. Production of good quality software using this method requires highly skilled and motivated programmers.
#### Example

### Prototyping  Model

The Prototyping Model is a systems development method (SDM) in which a prototype (an early approximation of a final system) displays the functionality of the product under development, but may not actually hold the exact logic of the original software (early copy of the system, used to understand the requirements). That is to say that it is built, tested, and then reworked as necessary until an acceptable prototype is finally achieved from which the complete system or product can now be developed (the prototype is essentially the frame work).

#### Advantages

The advantages that stem from the use of Prototyping consist of users being actively involved in the development, furthermore since in this methodology a working model of the system is provided, the users also get a better understanding of the system being developed.

Moreover errors, missing functionality and confusing functions can be detected and identified much earlier and more easily ,whilst quicker user feedback is available leading to better solutions.

#### Disadvantages

The disadvantges of the Prototype model is that it leads to implementing and then repairing way of building systems.
While practically, this methodology may increase the complexity of the system as scope of the system may expand beyond the original plans.
Moreover the application being  may cause the application not to be used as the full system was initially designed or intended.

#### Example 

The Prototype model should typically be applied when the desired system needs to have a lot of interaction with the end users.
This links commonly to , online systems and web interfaces that have a very high amount of interaction with end users, being best suited for Prototype model. though it may take time for a system to be built that allows ease of use and needs minimal training for the end user.

### Spiral Method

This Spiral model is a combination of iterative development process model and sequential linear development model i.e. the waterfall model with a very high emphasis on risk analysis. The spiral model has four phases: Planning, Risk Analysis, Engineering and Evaluation. Each subsequent spirals builds on the baseline spiral.

#### Advantages

The advantages for implementing the spiral model into practice consist of a high amount of risk analysis hence, avoidance of Risk is enhanced. Inaddition the model is particuarly  suitable for larger projects with storng approval and documentation control. Whilst the software is produced at an early stage in the software life cycle and additional functionality can be added at a later date.

#### Disadvantages

Though the model heralds numerous advantages it also has its own problems or disadvantages, theses being that it can be a costly model to use. Furthermore the risk analysis requires highly specific expertise and the project’s success is highly dependent on the risk analysis phase. This model is also not suited for smaller projects.

#### Examples

The spiral model in SDLC is very popular in software engineering, website and software development. Furthermore the Spiral Model should only be implemented When evaulating the costs and risk, and for medium to high risk projects, or where the requirements are complex or the users are unsure of their needs.Moreover the project should be a long term  commitment unwise because of potential changes to economic priorities (significant changes expected).

#### Spiral-lifecycle-model-Risk-Management

The Spiral life cycle is a risk-driven model which means that the overall success of a project highly depends on the risks analysis phase. Futher linking into how risks are managed in the model, analysis is critical,(manged through)identifying, estimating and monitoring the technical feasibility and management risks, such as schedule slippage and cost overrun. Moreover once the build is tested, at the end of first iteration, feedback on the software (evaluation) is retrieved or given, which can further help manage and avoid problems (implications/complications) or risks.

### Rapid Application Development (RAD)

Rapid application development is a software development methodology that uses minimal planning in favor of rapid prototyping.A prototype being a working model that is functionally equivalent to a component of the product, so essentially rapid application development follows a similiar a model, ideology to the prototyping modell, coming to a consensus.

#### Advantages

The advantages of Rapid Application Development are as follows; Changing requirements can be accommodated, Progress can be measured, Iteration time can be short with use of powerful RAD tools,Productivity with fewer people in a short time, Reduced development time, increases reusability of components and encourages customer feedback.

#### Disadvantages

The Disadvantages of Rapid Application Development are that there is dependency on technically strong team members for identifying business requirements.Whilst only systems that can be modularized can be built using RAD, which also requires highly skilled developers/designers.
Inaddition the model is inapplicable to cheaper projects as cost of modeling and automated code generation is very high.

#### Examples

RAD model can be applied successfully to the projects in which clear modularization is possible. If the project cannot be broken into modules, RAD may fail.

### TraditionalXAgile

#### Advantages

#### Disadvantages

#### Examples

### Formal / Light Formal


#### Advantages

#### Disadvantages

#### Examples

### Requirements Traceability 

Requirement Traceability is a proccess that is one part of an overarching requirements management practice and extends from a requirements definition through to the implementation. Requirement tracing is used to ensure that the development proccess is correct, conforms to the needs of prior and next steps in the development proccess and suits the defined requirements. 

#### How software requirements can be traced throughout the software lifecycle.

Software requirements may essentially be traced throughout the software lifecycle using tracability practices or requirement tracing, 
a method that defines the ability to describe and follow the life of a requirement in both a forward and backward direction,ideally through each step of the entire life cycle. However not all practices are bidirectional, though exceptional ones should be with the traceability chains being traced both forwards and backwards.

![Alt text](https://github.com/matthewsides/SDCL-Methodologies/blob/master/Bidirectional_Trace.jpg?raw=true "Optional Title")

Furthermore requirement tracing is implemented and achieved through documenting and tracking tracability relationships between requirements. A tracability relationship is a dependency relationship between project elements.Similiar to how a dynamic project element schedule may react to the alteration of a task, a change to a requirement element may also affect other elements. A well documented traceability relationship should clearly define requirement dependinces, thus allowing anaylisis of how the alteracations in requirements affect other requirements and the project as a whole.


Regardless of the project type,the model used to trace software requirements will be similiar throughout.The basic frame or structure for a tracability strategy is relatively common for most projects as it follows a hierachy from higher-level needs, through detailed requirements and then onto implementation. Project stages such as, development, support requirements that support product features that then all trace back to the a clients (stake holders/user/etc.) needs. Theses proccessess provide the capability to track or trace software requirements, ensuring that each requirement is completed to a standard, also verifying that each defined requirement has been addressed.


### Application Merits of the water fall method for Large Projects

Re-alliterating briefly the information covered underneath the waterfall sub-heading, the water fall method is a sequentian non-iterative design model , used in software development proccesses. This methods structure and flow  is similiar to that of a waterfall hence the term "waterfall". 

Moreover the water development lifecycle is primarly suited for large development projects,with the inclusion of an abundant amount of risks and  clear specifications of the end product outlook.In correlation to the posed question as to the merits of applying the Waterfall lifecycle model to a large software development project,this is a crucial point as it means that the implementation should be benifical. 

Large scale projects are usually arduous and run over a long period of time and therefore it is necassary to state the end goal near the beginning since tracing back or making alteractions could cause complications or the development team to have to restart from the beginning. Thus leading into the intial point as to why the application of the waterfall method to a large project is a merit, since the waterfall method model uses clear structure particularly in comparision to other methodologies breaking down the project into manageable stages, focusing on a clear, defined set of steps. Whilst the managing of project segments into blocks makes it less probable that half-finished projects will be sidelined, leaving teams with a more complete and polished project.In principle this clear structure should also prove useful to stake holders in addition to the development team as a conceptual idea of the end product may be formed and shown (illustrated).

As the Waterfall’s approach is highly methodical,the method emphasises a clean transfer of information at each step. Which when applied in a software setting every new step involves a new group of people,though not necassary always the case in every instance. The documentation of each stage throughout a project’s lifecycle is benifical,since the waterfall method prioritizes accessible information. This essentially means that new additions to the team may be updated as to the projects current condition extremely quickly. A merit in relation to the implmentation of a such a model in a large scale project, as a large scale project usually stems over a monumentous  time period, thus it would not be strange to see the team infrastructure change during development(meaning that the new members would need to be filled in).

Further expanding on the water falls simple and well layed out structure or frame, in regards to a large scale project, the pre-defined requirements, schedule, tasks, etc. would increase the team's efficency, ensuring time scales are kept with a clear outcome ,financial layout and test plan covered. This fudementally means that if the pre-set procedures, times etc. are followed with limited or no changes the rate in which the project is completed will along with the final outcome or quality increase. 

In comparision to a large scale project the application of the waterfall practice would not be benifical since smaller projects are likely to have a higher rate of change and include more communication between the team and the client, in contrast to how a "successful" large scale project heralds limited changes and details the end goal at the start. Though instances of large scale projects requireing altirications exist, this usually leads to a product of porr quality or an up heveal of the team and project restart.

Summarising the application of the Waterfall lifecycle model to a large software development project is recommended, particularly since the majority of large scale projects are not expected to change or to need new developments during the project lifecycle.Whilst the merit of documentation through the stages of a life cycle are seen. As a large scale project generally extends over a large period of time with team members beign dispensed or leaving, thus the merit of this waterfall feature enables new members to get up to speed quicker, backing the idea of utilising and merits of applying the Waterfall lifecycle model to a large software development project.
However it may been seen that it is critical that the software developers involved in the large scale project are able to guide and advise clients effectively in order to circumvent problems later (since communication and changes are limited).

### [3] FSM and EFSM

A finite state machine is a mathematical model, that can be any one finite states specified at a given time 
and transition to another state via external input.The finite state machine is considered boolean (meaning) in 
that a state is either on or off.

In a conventional finite state machine, the transition is associated with a set of input Boolean conditions and 
a set of output Boolean functions. 

In an extended finite state machine (EFSM) model, the transition is or can be expressed through 
the use of an “if statement” consisting of a set of trigger conditions.

An example of a finite state machine would be a traffic light, a traffic light includes 4 states;red, red amber,
amber and green. The red state signifys that all cars must stop,prohibiting the flow of traffic. Whilst the state tranisition between red to amber or red amber indicates that the signal is about to change to green. The amber state warns that the signal is about 
is about to transition or change to red.While the green light allows traffic to proceed in the direction denoted.
The states go in a decending and ascending order. 

In addition the traffic lights concurrent state is usually red not deviating unless either external input is given
through the press of a button linked or connected to the lights. The Traffic lights may also be motion sensored
or timed synonymously changing, adding another factor and removing the variable regarding external input.

![Alt text](https://github.com/matthewsides/SDCL-Methodologies/blob/master/State_Chart_Traffic_Light.jpg?raw=true "Optional Title")

An Extended finite state machine as alliterated above isnt to different to the finite state machine other than 
the decideing factor that FSM (finite-state-machine) is associated with booleans. While a EFSM (Extended-finite-state-machine)
is linked to "If Statements". The functions are devised may output the same outcome, it is in the way it gathers 
the external input and what it does with that input or how it functions thats different. For instance an elevator 
may be an Extended finite state machine or a finite state machine with a plefora of states depending on the 
amount of floors or scenarios circumstances.

A State machine is usually illustrated or described through a Statechart. State machine (as alliteratted above) can be defined as a machine which defines different states of an object and these states are controlled by external or internal events (e.g finite state machine, extended finite state machine). The UML state chart describes the different states of a component in a system, illustrating the transitions and possible outcomes. The image displayed above regarding the finite state machine, traffic lights is a UML state chart diagram.


### [4] Behavioural  Specification Methods

#### UML State Chart

The UML State chart describes different states of a component in a system. The states are specific to a component/object of a system. The statechart diagram is one of the five UML diagrams used to model the dynamic nature of a system. They define different states of an object during its lifetime and these states are altered by events. State charts are useful when modeling reactive systems (systems that respond to external or internal events).

A Statechart diagram describes the flow of control from one state to another state. States are defined as a condition in which an object exists, that changes when a pre-set event is triggered. The most important purpose of Statechart diagram is to model lifetime of an object from creation to termination.


Through delving into the practical implementation of a Statechart diagram, it is clear that the chart is primary or  mainly used to analyze the object states influenced by events. This analysis is helpful to understand the system behavior during its execution. An illustration of a state chart and real life application may be seen through a Microwave. As a Microwave includes a set number of states that may change depending on events being triggered, if conditions are met (input given/internal/external). The UML State chart for a microwave is displayed below, showing the state transitions. 

![Alt text](https://github.com/matthewsides/SDCL-Methodologies/blob/master/state_diagram_microwave.png?raw=true "Optional Title")

#### Activity diagram 

An Activity diagram is another diagram in UML, used  to describe the dynamic aspects of the system. The Activity diagram is essentially a flowchart used to represent the flow from one activity to another activity. The activity can be described as an operation of the system.

The control flow is drawn from one operation to another. This flow can be sequential, branched, or concurrent. Activity diagrams deal with all type of flow control by using different elements such as fork, join, etc.

The Activity diagram is similiar to other UML diagrams in regards to capturing the dynamic behaviour of a system.However the four diagrams are used to show the message flow from one object to another, whilst the activity diagram is used to show message flow from one activity to another.

Activity is a particular operation of the system. Activity diagrams are not only used for visualising the dynamic nature of a system, but they are also used to construct the executable system by using forward and reverse engineering techniques. Though the Activity diagram does not show any message flow from one activity to another. 

The Activity diagram is often likened or considered as the flowchart. This is due to the diagrams looking like a flow chart, however the diagrams are not, showing different flows such as parallel, branched, concurrent, and single. An instance of where a Activity diagram would be applied is in an ATM system, used to illustrate and describe the possible outcomes and proccess. The Activity diagram shown below describes and illustrates the theory behind the proccess of withdrawing money.

![Alt text](https://github.com/matthewsides/SDCL-Methodologies/blob/master/Activity_Diagram_ATM.png?raw=true "Optional Title")

### [5] How the use of the function design paradigm in the software development lifecycle can improve software quality

The function design paradigm is a paradigm used to simplify the design of software.A functional design assures that each modular part of a system has only one responsibility and performs that responsibility with the minimum of side effects on other parts. 

The application of the function design paradigm in the software development life cycle can improve software quality, though it is dependant on the software being developed and model used. For instance,the implementation for a software module with a single purpose, will be ensure that the proccess is simpler, and therefore easier and less expensive, to design and implement.Thus it may be seen that the functional design paradigm would function better with the water fall life cycle.

Whilst Systems with functionally designed parts would be easier to modify because each part does only what it claims to do. Moreover since maintenance is spanned over the majority of a systems life, this feature is a crucial advantage. It also makes the system easier to understand and document, which inturn simplifies training and improves the softwares ease of use. The result is that the practical lifetime of a functional system is longer. Whilst in a system of programs, a functional module will be easier to reuse, this consequently improving the software because it is less likely to have side effects that appear in other parts of the system.

However the application of the function design paradigm  in software development also heralds disadvantages with regards to software quality, as a computer system has intergrated parts that cannot be functionally pure because they exist to distribute CPU cycles or other resources to different modules. For instance the majority of systems have an "initialization" section that starts up the modules

While some functions  inherently have mixed semantics.This meaning that for instance a function to move an object from one positiion to another,inherently has a side effect of changing the "object position". In some cases, the mixed semantics can extend over a large topological tree or graph of related concepts. In theses circumstances or scenarios it is suggested or recommended not to use functional design but rather procedural,  polymorphism or inheritance methods as the preference.

Summarising the points covered above the use of the function design paradigm in the software development lifecycle can improve software quality, through extending the softwares life expectancy with maintanence,interpretable and easy to document. This in turn improves the software quality and ease of use as it is easier to train user's.  Whilst the implemetnation for a software module with a single purpose, ensures that the proccess is simpler, and therefore easier and less expensive, to design and implement. The functional module will also be easier to reuse, this consequently improving the software because it is less likely to have side effects that appear in other parts of the system. 

### [6] How data driven software can improve the reliability and effectiveness of software

Data driven software engineering can support and increase the reliability and effectiveness of  software. The effectiveness and reliability of software is essentially improved due to the data driven software engineering techniques, software functionality only requiring that the abstract data type of variables that it is working with is known. Functions and interfaces can also be used on all objects with the same data fields, for instance the object's "position". Data can be grouped into objects or "entities" according to preference with little to no consequence.

However though data-driven design does prevent coupling of data and functionality,data-driven programming has been argued to lead to bad object-oriented design, especially when dealing with more abstract data. This is because a purely data-driven object or entity is defined by the way it is represented. Any attempt to change the structure of the object would immediately break the functions that rely on it.


